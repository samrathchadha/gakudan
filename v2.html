<!DOCTYPE html>
<html>
<head>
    <title>Graph Visualization with Enhanced RAG Connections</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
        }
        #graph {
            width: 100%;
            height: 700px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .node circle {
            stroke: #fff;
            stroke-width: 2px;
            cursor: pointer;
        }
        .node text {
            font-size: 12px;
            pointer-events: none;
            fill: #333;
        }
        .link {
            stroke-opacity: 0.6;
            stroke-width: 1.5px;
        }
        .hierarchy-link {
            stroke: #999;
        }
        .rag-link {
            stroke: #0066cc;
            stroke-dasharray: 5,5;
        }
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 10;
            display: none;
            max-width: 300px;
            word-wrap: break-word;
        }
        .controls {
            margin-bottom: 20px;
        }
        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 5px;
        }
        .legend-line {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .legend-line-sample {
            width: 30px;
            height: 2px;
            margin-right: 5px;
        }
        .error-message {
            color: red;
            background-color: #ffeeee;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
        }
        #stats {
            margin-top: 15px;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 4px;
        }
        button {
            padding: 8px 12px;
            margin-right: 5px;
            cursor: pointer;
        }
        input[type="file"] {
            padding: 8px;
            margin-right: 10px;
        }
        .node-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #ccc;
            max-width: 400px;
            max-height: 300px;
            overflow-y: auto;
        }
        .toggle-button {
            margin-left: 10px;
            padding: 5px 10px;
            cursor: pointer;
        }
        .connection-count {
            margin-left: 10px;
            font-weight: bold;
        }
    </style>
</head>
<body>

<h1>Graph Visualization with Enhanced RAG Connections</h1>

<div id="error" class="error-message" style="display:none;"></div>

<div class="controls">
    <input type="file" id="jsonFileInput" accept=".json">
    <button id="zoomIn">Zoom In</button>
    <button id="zoomOut">Zoom Out</button>
    <button id="resetZoom">Reset View</button>
    <button id="fixMalformedJSON">Fix Malformed JSON</button>
    <button id="toggleRagLinks" class="toggle-button">Toggle RAG Links</button>
    <button id="toggleHierarchyLinks" class="toggle-button">Toggle Hierarchy Links</button>
    <span id="connectionCount" class="connection-count"></span>
</div>

<div id="stats"></div>
<div id="graph"></div>
<div id="legend" class="legend" style="display:none;"></div>
<div id="tooltip" class="tooltip"></div>
<div id="nodeInfo" class="node-info" style="display:none;"></div>

<script>
    // DOM elements
    const graph = document.getElementById('graph');
    const statsDiv = document.getElementById('stats');
    const errorDiv = document.getElementById('error');
    const nodeInfoDiv = document.getElementById('nodeInfo');
    const connectionCountSpan = document.getElementById('connectionCount');
    
    // Graph dimensions
    const width = graph.clientWidth;
    const height = graph.clientHeight;

    // Create SVG and main group
    const svg = d3.select("#graph")
        .append("svg")
        .attr("width", width)
        .attr("height", height);

    const g = svg.append("g");

    // Setup zoom behavior
    const zoom = d3.zoom()
        .scaleExtent([0.1, 4])
        .on("zoom", (event) => g.attr("transform", event.transform));

    svg.call(zoom);

    // Tooltip
    const tooltip = d3.select("#tooltip");

    // Visibility toggles
    let showRagLinks = true;
    let showHierarchyLinks = true;

    // Color palette for depth visualization
    const colorPalette = [
        "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", 
        "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf",
        "#aec7e8", "#ffbb78", "#98df8a", "#ff9896", "#c5b0d5",
        "#c49c94", "#f7b6d2", "#c7c7c7", "#dbdb8d", "#9edae5"
    ];

    let colorMap = {};
    let simulation;
    let rawData = null;
    let currentNodes = [];
    let currentLinks = [];
    let hierarchyLinks = [];
    let ragLinks = [];

    // Event listeners
    document.getElementById('jsonFileInput').addEventListener('change', handleFileSelect);
    document.getElementById('zoomIn').addEventListener('click', () => svg.transition().call(zoom.scaleBy, 1.5));
    document.getElementById('zoomOut').addEventListener('click', () => svg.transition().call(zoom.scaleBy, 0.75));
    document.getElementById('resetZoom').addEventListener('click', () => svg.transition().call(zoom.transform, d3.zoomIdentity));
    document.getElementById('fixMalformedJSON').addEventListener('click', attemptToFixJSON);
    document.getElementById('toggleRagLinks').addEventListener('click', toggleRagLinks);
    document.getElementById('toggleHierarchyLinks').addEventListener('click', toggleHierarchyLinks);

    // Toggle RAG links
    function toggleRagLinks() {
        showRagLinks = !showRagLinks;
        updateLinkVisibility();
    }

    // Toggle hierarchy links
    function toggleHierarchyLinks() {
        showHierarchyLinks = !showHierarchyLinks;
        updateLinkVisibility();
    }

    // Update link visibility based on toggles
    function updateLinkVisibility() {
        if (simulation) {
            // Update visible links based on toggles
            const visibleLinks = [];
            
            if (showHierarchyLinks) {
                visibleLinks.push(...hierarchyLinks);
            }
            
            if (showRagLinks) {
                visibleLinks.push(...ragLinks);
            }
            
            // Update link data
            const link = g.selectAll(".link")
                .data(visibleLinks);
            
            // Remove links not in the updated data
            link.exit().remove();
            
            // Add new links
            const linkEnter = link.enter()
                .append("line")
                .attr("class", d => {
                    const isRag = isRagConnection(d);
                    return `link ${isRag ? 'rag-link' : 'hierarchy-link'}`;
                });
            
            // Merge and update all links
            link.merge(linkEnter)
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);
            
            // Update connection count display
            updateConnectionCount();
        }
    }

    // Update connection count display
    function updateConnectionCount() {
        const hierarchyCount = showHierarchyLinks ? hierarchyLinks.length : 0;
        const ragCount = showRagLinks ? ragLinks.length : 0;
        connectionCountSpan.textContent = `Showing: ${hierarchyCount} hierarchy, ${ragCount} RAG connections`;
    }

    // File handling
    function handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                // Try to parse the JSON
                rawData = e.target.result;
                const data = JSON.parse(rawData);
                hideError();
                processGraphData(data);
            } catch (error) {
                // Show error and suggest fix
                showError(`Error parsing JSON: ${error.message}. Try using the "Fix Malformed JSON" button.`);
                console.error('Error parsing JSON:', error);
            }
        };
        reader.readAsText(file);
    }

    // Attempt to fix malformed JSON
    function attemptToFixJSON() {
        if (!rawData) {
            showError("No data loaded. Please upload a JSON file first.");
            return;
        }

        try {
            // Basic cleanup - replace multiple whitespaces, fix common issues
            let cleanedData = rawData
                .replace(/,\s*}(?!\s*[,\]])/g, '}') // Remove trailing commas
                .replace(/,\s*\](?!\s*[,\]])/g, ']') // Remove trailing commas in arrays
                .replace(/([{,])\s*(\w+)\s*:/g, '$1"$2":') // Add quotes to property names
                .replace(/:\s*'([^']*)'/g, ':"$1"'); // Replace single quotes with double quotes

            // Try to extract valid nodes and links
            let match;
            let nodes = [];
            let links = [];

            // Extract the "nodes" array
            const nodesMatch = cleanedData.match(/"nodes"\s*:\s*\[([\s\S]*?)\]/);
            if (nodesMatch && nodesMatch[1]) {
                const nodesText = `[${nodesMatch[1]}]`;
                try {
                    nodes = JSON.parse(nodesText.replace(/,\s*$/,'')); // Remove trailing comma
                } catch (e) {
                    console.error("Could not parse nodes:", e);
                }
            }

            // Extract the "links" array
            const linksMatch = cleanedData.match(/"links"\s*:\s*\[([\s\S]*?)\]/);
            if (linksMatch && linksMatch[1]) {
                const linksText = `[${linksMatch[1]}]`;
                try {
                    links = JSON.parse(linksText.replace(/,\s*$/,'')); // Remove trailing comma
                } catch (e) {
                    console.error("Could not parse links:", e);
                }
            }

            // If we have some valid nodes, proceed
            if (nodes.length > 0) {
                hideError();
                // Filter nodes to only include those with prompts
                nodes = nodes.filter(node => node && node.id);
                showMessage(`Fixed JSON data: Found ${nodes.length} nodes.`);
                processGraphData({ nodes, links });
            } else {
                showError("Could not extract valid nodes from the JSON data.");
            }
        } catch (error) {
            showError(`Error fixing JSON: ${error.message}`);
            console.error('Error fixing JSON:', error);
        }
    }

    // Show error message
    function showError(message) {
        errorDiv.textContent = message;
        errorDiv.style.display = 'block';
    }

    // Hide error message
    function hideError() {
        errorDiv.style.display = 'none';
    }

    // Show stats message
    function showMessage(message) {
        statsDiv.textContent = message;
        statsDiv.style.display = 'block';
    }

    // Check if a link is a RAG connection
    function isRagConnection(link) {
        return link.edge_type === "rag" || 
               link.link_type === "rag" || 
               link.rag_connection === true ||
               link.type === "rag";
    }

    // Process graph data
    function processGraphData(data) {
        // Clear the graph
        g.selectAll("*").remove();

        // Extract nodes and links
        let nodes = data.nodes || [];
        let links = data.links || [];

        // Filter out nodes without IDs
        nodes = nodes.filter(node => node && node.id);
        
        // Create nodemap for faster lookups
        const nodeMap = new Map();
        nodes.forEach(node => nodeMap.set(node.id, node));
        
        // Filter links - ensure both source and target exist in our filtered node set
        links = links.filter(link => {
            const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
            const targetId = typeof link.target === 'object' ? link.target.id : link.target;
            return nodeMap.has(sourceId) && nodeMap.has(targetId);
        });

        // Categorize links by type
        hierarchyLinks = links.filter(link => !isRagConnection(link));
        ragLinks = links.filter(link => isRagConnection(link));

        // Display stats
        const hierarchyCount = hierarchyLinks.length;
        const ragCount = ragLinks.length;
        showMessage(`Visualizing ${nodes.length} nodes with ${hierarchyCount} hierarchy connections and ${ragCount} RAG connections.`);
        updateConnectionCount();

        // Map colors to depths
        const uniqueDepths = [...new Set(nodes.map(node => node.depth))].sort((a, b) => a - b);
        colorMap = uniqueDepths.reduce((map, depth, i) => {
            map[depth] = colorPalette[i % colorPalette.length];
            return map;
        }, {});

        // Store current data
        currentNodes = nodes;
        currentLinks = links;

        // Create legend and visualize graph
        createLegend(colorMap);
        visualizeGraph(nodes);
    }

    // Create color legend
    function createLegend(colorMap) {
        const legend = document.getElementById('legend');
        legend.innerHTML = '';
        legend.style.display = 'block';

        // Add depth colors
        Object.entries(colorMap).forEach(([depth, color]) => {
            const item = document.createElement('div');
            item.className = 'legend-item';
            item.innerHTML = `
                <div class="legend-color" style="background-color: ${color};"></div>
                Depth ${depth}
            `;
            legend.appendChild(item);
        });

        // Add separator
        legend.appendChild(document.createElement('hr'));

        // Add link types
        const hierarchyLine = document.createElement('div');
        hierarchyLine.className = 'legend-line';
        hierarchyLine.innerHTML = `
            <div class="legend-line-sample hierarchy-link" style="background-color: #999;"></div>
            Hierarchy Connection
        `;
        legend.appendChild(hierarchyLine);

        const ragLine = document.createElement('div');
        ragLine.className = 'legend-line';
        ragLine.innerHTML = `
            <div class="legend-line-sample rag-link" style="background-color: #0066cc;"></div>
            RAG Connection
        `;
        legend.appendChild(ragLine);
    }

    // Visualize the graph
    function visualizeGraph(nodes) {
        // Configure simulation
        simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink()
                .id(d => d.id)
                .distance(100))
            .force("charge", d3.forceManyBody().strength(-300))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collide", d3.forceCollide(20));

        // Determine which links to show initially
        const initialLinks = [];
        if (showHierarchyLinks) {
            initialLinks.push(...hierarchyLinks);
        }
        if (showRagLinks) {
            initialLinks.push(...ragLinks);
        }

        // Create links with proper styling
        const link = g.selectAll(".link")
            .data(initialLinks)
            .enter().append("line")
            .attr("class", d => {
                const isRag = isRagConnection(d);
                return `link ${isRag ? 'rag-link' : 'hierarchy-link'}`;
            });

        // Create nodes
        const node = g.selectAll(".node")
            .data(nodes)
            .enter().append("g")
            .attr("class", "node")
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

        // Create node circles
        node.append("circle")
            .attr("r", d => d.id === "root" ? 15 : 10)
            .attr("fill", d => colorMap[d.depth] || "#ccc");

        // Create node labels
        node.append("text")
            .attr("dx", 12)
            .attr("dy", ".35em")
            .text(d => {
                if (d.prompt) {
                    return (d.prompt.substring(0, 20) + (d.prompt.length > 20 ? '...' : ''));
                } else {
                    return d.id.substring(0, 8) + '...';
                }
            });

        // Add tooltips
        node.on("mouseover", (event, d) => {
            tooltip.style("display", "block")
                .html(`
                    <strong>ID:</strong> ${d.id}<br>
                    <strong>Depth:</strong> ${d.depth}<br>
                    ${d.prompt ? `<strong>Prompt:</strong> ${d.prompt.substring(0, 100)}${d.prompt.length > 100 ? '...' : ''}` : ''}
                `)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 10) + "px");
        })
        .on("mouseout", () => tooltip.style("display", "none"))
        .on("click", (event, d) => {
            // Show detailed node info
            nodeInfoDiv.innerHTML = `
                <h3>Node Details</h3>
                <p><strong>ID:</strong> ${d.id}</p>
                <p><strong>Depth:</strong> ${d.depth}</p>
                ${d.prompt ? `<p><strong>Prompt:</strong> ${d.prompt}</p>` : ''}
                ${d.response ? `<p><strong>Response:</strong> ${d.response.substring(0, 300)}${d.response.length > 300 ? '...' : ''}</p>` : ''}
                ${d.rag_results ? `<p><strong>RAG Results:</strong> ${d.rag_results.length} sources</p>` : ''}
            `;
            
            // Show incoming RAG connections
            const incomingRag = ragLinks.filter(link => 
                (typeof link.target === 'object' ? link.target.id : link.target) === d.id
            );
            
            if (incomingRag.length > 0) {
                nodeInfoDiv.innerHTML += `<p><strong>Incoming RAG connections:</strong> ${incomingRag.length}</p>`;
            }
            
            // Show outgoing RAG connections
            const outgoingRag = ragLinks.filter(link => 
                (typeof link.source === 'object' ? link.source.id : link.source) === d.id
            );
            
            if (outgoingRag.length > 0) {
                nodeInfoDiv.innerHTML += `<p><strong>Outgoing RAG connections:</strong> ${outgoingRag.length}</p>`;
            }
            
            nodeInfoDiv.style.display = "block";
            
            // Highlight connections
            highlightConnections(d.id);
        });

        // Function to highlight connections for a node
        function highlightConnections(nodeId) {
            // Reset all links
            g.selectAll(".link")
                .style("opacity", 0.3)
                .style("stroke-width", 1.5);
                
            // Highlight links connected to this node
            g.selectAll(".link")
                .filter(d => {
                    const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                    const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                    return sourceId === nodeId || targetId === nodeId;
                })
                .style("opacity", 1)
                .style("stroke-width", 3);
        }

        // Update positions on simulation tick
        simulation.force("link").links(initialLinks);
        
        simulation.on("tick", () => {
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            node.attr("transform", d => `translate(${d.x},${d.y})`);
        });

        // Drag functions
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            // Pin nodes after dragging (comment these out to unpin)
            // d.fx = null;
            // d.fy = null;
        }
    }
</script>

</body>
</html>