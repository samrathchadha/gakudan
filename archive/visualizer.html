<!DOCTYPE html>
<html>
<head>
    <title>Graph Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
        }
        #graph {
            width: 100%;
            height: 700px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .node circle {
            stroke: #fff;
            stroke-width: 2px;
            cursor: pointer;
        }
        .node text {
            font-size: 12px;
            pointer-events: none;
            fill: #333;
        }
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 1.5px;
        }
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 10;
            display: none;
            max-width: 300px;
            word-wrap: break-word;
        }
        .controls {
            margin-bottom: 20px;
        }
        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 5px;
        }
        .error-message {
            color: red;
            background-color: #ffeeee;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
        }
        #stats {
            margin-top: 15px;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 4px;
        }
        button {
            padding: 8px 12px;
            margin-right: 5px;
            cursor: pointer;
        }
        input[type="file"] {
            padding: 8px;
            margin-right: 10px;
        }
        .node-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #ccc;
            max-width: 300px;
        }
    </style>
</head>
<body>

<h1>Graph Visualization</h1>

<div id="error" class="error-message" style="display:none;"></div>

<div class="controls">
    <input type="file" id="jsonFileInput" accept=".json">
    <button id="zoomIn">Zoom In</button>
    <button id="zoomOut">Zoom Out</button>
    <button id="resetZoom">Reset View</button>
    <button id="fixMalformedJSON">Fix Malformed JSON</button>
</div>

<div id="stats"></div>
<div id="graph"></div>
<div id="legend" class="legend" style="display:none;"></div>
<div id="tooltip" class="tooltip"></div>
<div id="nodeInfo" class="node-info" style="display:none;"></div>

<script>
    // DOM elements
    const graph = document.getElementById('graph');
    const statsDiv = document.getElementById('stats');
    const errorDiv = document.getElementById('error');
    const nodeInfoDiv = document.getElementById('nodeInfo');
    
    // Graph dimensions
    const width = graph.clientWidth;
    const height = graph.clientHeight;

    // Create SVG and main group
    const svg = d3.select("#graph")
        .append("svg")
        .attr("width", width)
        .attr("height", height);

    const g = svg.append("g");

    // Setup zoom behavior
    const zoom = d3.zoom()
        .scaleExtent([0.1, 4])
        .on("zoom", (event) => g.attr("transform", event.transform));

    svg.call(zoom);

    // Tooltip
    const tooltip = d3.select("#tooltip");

    // Color palette for depth visualization
    const colorPalette = [
        "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", 
        "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf",
        "#aec7e8", "#ffbb78", "#98df8a", "#ff9896", "#c5b0d5",
        "#c49c94", "#f7b6d2", "#c7c7c7", "#dbdb8d", "#9edae5"
    ];

    let colorMap = {};
    let simulation;
    let rawData = null;

    // Event listeners
    document.getElementById('jsonFileInput').addEventListener('change', handleFileSelect);
    document.getElementById('zoomIn').addEventListener('click', () => svg.transition().call(zoom.scaleBy, 1.5));
    document.getElementById('zoomOut').addEventListener('click', () => svg.transition().call(zoom.scaleBy, 0.75));
    document.getElementById('resetZoom').addEventListener('click', () => svg.transition().call(zoom.transform, d3.zoomIdentity));
    document.getElementById('fixMalformedJSON').addEventListener('click', attemptToFixJSON);

    // File handling
    function handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                // Try to parse the JSON
                rawData = e.target.result;
                const data = JSON.parse(rawData);
                hideError();
                processGraphData(data);
            } catch (error) {
                // Show error and suggest fix
                showError(`Error parsing JSON: ${error.message}. Try using the "Fix Malformed JSON" button.`);
                console.error('Error parsing JSON:', error);
            }
        };
        reader.readAsText(file);
    }

    // Attempt to fix malformed JSON
    function attemptToFixJSON() {
        if (!rawData) {
            showError("No data loaded. Please upload a JSON file first.");
            return;
        }

        try {
            // Basic cleanup - replace multiple whitespaces, fix common issues
            let cleanedData = rawData
                .replace(/,\s*}(?!\s*[,\]])/g, '}') // Remove trailing commas
                .replace(/,\s*\](?!\s*[,\]])/g, ']') // Remove trailing commas in arrays
                .replace(/([{,])\s*(\w+)\s*:/g, '$1"$2":') // Add quotes to property names
                .replace(/:\s*'([^']*)'/g, ':"$1"'); // Replace single quotes with double quotes

            // Try to extract valid nodes and links
            let match;
            let nodes = [];
            let links = [];

            // Extract the "nodes" array
            const nodesMatch = cleanedData.match(/"nodes"\s*:\s*\[([\s\S]*?)\]/);
            if (nodesMatch && nodesMatch[1]) {
                const nodesText = `[${nodesMatch[1]}]`;
                try {
                    nodes = JSON.parse(nodesText.replace(/,\s*$/,'')); // Remove trailing comma
                } catch (e) {
                    console.error("Could not parse nodes:", e);
                }
            }

            // Extract the "links" array
            const linksMatch = cleanedData.match(/"links"\s*:\s*\[([\s\S]*?)\]/);
            if (linksMatch && linksMatch[1]) {
                const linksText = `[${linksMatch[1]}]`;
                try {
                    links = JSON.parse(linksText.replace(/,\s*$/,'')); // Remove trailing comma
                } catch (e) {
                    console.error("Could not parse links:", e);
                }
            }

            // If we have some valid nodes, proceed
            if (nodes.length > 0) {
                hideError();
                // Filter nodes to only include those with prompts
                nodes = nodes.filter(node => node && node.prompt && node.response);
                showMessage(`Fixed JSON data: Found ${nodes.length} nodes with prompts.`);
                processGraphData({ nodes, links });
            } else {
                showError("Could not extract valid nodes from the JSON data.");
            }
        } catch (error) {
            showError(`Error fixing JSON: ${error.message}`);
            console.error('Error fixing JSON:', error);
        }
    }

    // Show error message
    function showError(message) {
        errorDiv.textContent = message;
        errorDiv.style.display = 'block';
    }

    // Hide error message
    function hideError() {
        errorDiv.style.display = 'none';
    }

    // Show stats message
    function showMessage(message) {
        statsDiv.textContent = message;
        statsDiv.style.display = 'block';
    }

    // Process graph data
    function processGraphData(data) {
        // Clear the graph
        g.selectAll("*").remove();

        // Extract nodes and links
        let nodes = data.nodes || [];
        let links = data.links || [];

        // Filter out nodes without prompts
        nodes = nodes.filter(node => node && node.id && node.prompt);
        
        // Create nodemap for faster lookups
        const nodeMap = new Map();
        nodes.forEach(node => nodeMap.set(node.id, node));
        
        // Filter links - ensure both source and target exist in our filtered node set
        links = links.filter(link => {
            const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
            const targetId = typeof link.target === 'object' ? link.target.id : link.target;
            return nodeMap.has(sourceId) && nodeMap.has(targetId);
        });

        // Display stats
        showMessage(`Visualizing ${nodes.length} nodes with prompts and ${links.length} relevant links.`);

        // Map colors to depths
        const uniqueDepths = [...new Set(nodes.map(node => node.depth))].sort((a, b) => a - b);
        colorMap = uniqueDepths.reduce((map, depth, i) => {
            map[depth] = colorPalette[i % colorPalette.length];
            return map;
        }, {});

        // Create legend and visualize graph
        createLegend(colorMap);
        visualizeGraph(nodes, links, colorMap);
    }

    // Create color legend
    function createLegend(colorMap) {
        const legend = document.getElementById('legend');
        legend.innerHTML = '';
        legend.style.display = 'block';

        Object.entries(colorMap).forEach(([depth, color]) => {
            const item = document.createElement('div');
            item.className = 'legend-item';
            item.innerHTML = `
                <div class="legend-color" style="background-color: ${color};"></div>
                Depth ${depth}
            `;
            legend.appendChild(item);
        });
    }

    // Visualize the graph
    function visualizeGraph(nodes, links, colorMap) {
        // Configure simulation
        simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links)
                .id(d => d.id)
                .distance(100))
            .force("charge", d3.forceManyBody().strength(-300))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collide", d3.forceCollide(20));

        // Create links
        const link = g.selectAll(".link")
            .data(links)
            .enter().append("line")
            .attr("class", "link");

        // Create nodes
        const node = g.selectAll(".node")
            .data(nodes)
            .enter().append("g")
            .attr("class", "node")
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

        // Create node circles
        node.append("circle")
            .attr("r", d => d.id === "root" ? 15 : 10)
            .attr("fill", d => colorMap[d.depth] || "#ccc");

        // Create node labels
        node.append("text")
            .attr("dx", 12)
            .attr("dy", ".35em")
            .text(d => d.prompt.substring(0, 25) + (d.prompt.length > 25 ? '...' : ''));

        // Add tooltips
        node.on("mouseover", (event, d) => {
            tooltip.style("display", "block")
                .html(`
                    <strong>ID:</strong> ${d.id}<br>
                    <strong>Depth:</strong> ${d.depth}<br>
                    <strong>Prompt:</strong> ${d.prompt}
                `)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 10) + "px");
        })
        .on("mouseout", () => tooltip.style("display", "none"))
        .on("click", (event, d) => {
            // Show detailed node info
            nodeInfoDiv.innerHTML = `
                <h3>Node Details</h3>
                <p><strong>ID:</strong> ${d.id}</p>
                <p><strong>Depth:</strong> ${d.depth}</p>
                <p><strong>Prompt:</strong> ${d.prompt}</p>
                ${d.response ? `<p><strong>Response:</strong> ${d.response.substring(0, 200)}${d.response.length > 200 ? '...' : ''}</p>` : ''}
            `;
            nodeInfoDiv.style.display = "block";
        });

        // Update positions on simulation tick
        simulation.on("tick", () => {
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            node.attr("transform", d => `translate(${d.x},${d.y})`);
        });

        // Drag functions
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            // Uncomment to unpin nodes after dragging:
            // d.fx = null;
            // d.fy = null;
        }
    }
</script>

</body>
</html>